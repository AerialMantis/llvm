= sycl_ext_oneapi_non_uniform_sub_groups

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en

:blank: pass:[ +]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}


== Notice

[%hardbreaks]
Copyright (C) 2022-2023 Intel Corporation.  All rights reserved.

Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are trademarks
of The Khronos Group Inc.  OpenCL(TM) is a trademark of Apple Inc. used by
permission by Khronos.


== Contact

To report problems with this extension, please open a new issue at:

https://github.com/intel/llvm/issues


== Dependencies

This extension is written against the SYCL 2020 revision 6 specification.  All
references below to the "core SYCL specification" or to section numbers in the
SYCL specification refer to that revision.

This extension also depends on the following other SYCL extensions:

* link:https://github.com/intel/llvm/pull/4950[prospective proposal]
* link:https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/SubGroupMask/SubGroupMask.asciidoc[sub group mask proposal]
* link:https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/sycl_ext_oneapi_root_group/sycl_ext_oneapi_root_group.asciidoc[sycl_ext_oneapi_root_group]


== Status

This is a proposed extension specification, intended to gather community
feedback.  Interfaces defined in this specification may not be implemented yet
or may be in a preliminary state.  The specification itself may also change in
incompatible ways before it is finalized.  *Shipping software products should
not rely on APIs defined in this specification.*


== Overview

To fully exploit the available resources, modern hardware architectures allow
for further sub-divisions of sub-groups. Managing synchronization in divergent
control-flow can become awkward, especially when programming library code.
This proposal introduces new classes to represent sub-divisions of SYCL
sub-groups, allowing for easier synchronization and cooperation. These new
classes can be used as function arguments to convey exactly what group the
function is expecting, simplifying the interface and greatly reducing the amount
of delicate wording needed in function documentation. The group functions and
algorithms will also be updated to simplify use of these groups.

This extension introduces additions to the SYCL execution model which allows for
non-uniform sub-group types which can be created from sub-groups in order to
support various use cases of divergent control flow and independent forward
progress.

The extension introduces new classes for these group types, traits for detecting
them and free functions for creating them.


== Specification

=== Execution model extensions

The SYCL execution model is extended in order to support the introduction of
non-uniform sub-group types and the associated algorithms.

==== Fixed topology groups

The group types which form the existing SYCL execution model topology of
nd-range, work-group and sub-group are part of the fixed nd-range topology, and
are considered fixed topology group types. These are established at the point a
SYCL kernel function is enqueued and do not change throughout execution.

If the sycl_ext_oneapi_root_group extension is supported, then the `root_group`
class introduced by that extension is considered a fixed topology group type.

==== User-constructed groups

Other group types which do not fall into the fixed nd-range topology and are
instead constructed within a SYCL kernel function during execution are
considered user-constructed group types.

==== Control flow

Control flow is defined in the SYCL specification link:https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#glossary[glossary].

==== Common control flow

Two or more work-items are considered to have common control flow for a given
point if at some point during execution they will execute the same sequence of
statements.

==== Divergent control flow

Two or more work-items are considered to have divergent control flow for a given
point if at some point during execution they will execute a different sequence
of statements.

==== Active control flow

A work-item is considered to have active control flow for a given point of
execution if it follows the sequence of statements currently being executed.

==== Concurrent execution

Two or more work-items are considered to have concurrent execution at a given
point if they execute together. The amount of and granularity of concurrent
execution is implementation defined.

Itâ€™s permitted for two or more work-items to have concurrent execution without
having active control flow, when this happens the work-items without active
control flow are said to be masked.

==== Tangle

A tangle is a collection of work-items from the same sub-group which have common
control flow.

==== Concurrent tangle

A concurrent tangle is a collection of work-items from the same sub-group which
have common control flow and concurrent execution.

==== Independent forward progress

Independent forward progess refers to the ability of individual work-items to
execute a sequence of instructions regardless of when other work-items are
executing or which instructions other work-items are executing.

Portable SYCL programs must assume independent forward progress may be supported
by the hardware, since this ability is implementation defined as specified in
link:https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#_forward_progress[section 3.8.3.4]
of the SYCL specification.

==== Cluster-group

A cluster-group is a subset of a sub-group, representing a contiguous
collection of work-items within the sub-group resulting from an equal
subdivision of the sub-group.

The work-items of a cluster-group are required to be contiguous.

==== Ballot-group

A ballot-group is a subset of a sub-group, representing a collection of
work-items within the sub-group resulting from a predicate.

The work-items of a ballot-group are not required to be contiguous.

==== Tangle-group

A tangle-group is a subset of a sub-group, representing the work-items of a
tangle.

The work-items of a tangle-group are not required to be contiguous.

==== Opportunistic-group

An opportunistic-group is a subset of a sub-group, representing the work-items
of a concurrent tangle.

The work-items of an opportunistic-group are not required to be contiguous.

=== Class `ballot_group`

Currently in SYCL, synchronization cannot be performed on divergent control flow;
all work-items must converge. A ballot-group is a non-uniform sub-group type
which represents a subset of the work-items within a sub-group for which a given
predicate is either true or false. This allows group algorithms to be performed
on a subset of the work-items within a sub-group which all follow the same
control flow.

The sub-group or non-uniform sub-group that is divided will be referred to as
the source group. The creation of a ballot-group requires the synchronization of
the source group since details of the other work-items in the ballot-group will
be broadcast to participating work-items. Ballot-groups are created in a range
of two; the first containing all work-items where the predicate is true, and the
second containing all work-items where the predicate is false.

The `ballot_group` class represents a ballot-group, the work-items of sub-group
for which the predicate was either true or false.

[source, c++]
----
namespace sycl::ext::oneapi {
class ballot_group {
public:
    using id_type = id<1>;
    using range_type = range<1>;
    using linear_id_type = uint32_t;
    static constexpr int dimensions = 1;
    static constexpr sycl::memory_scope fence_scope =
        sycl::memory_scope::sub_group;
    
    id_type get_group_id() const;

    id_type get_local_id() const;

    range_type get_group_range() const;

    range_type get_local_range() const;

    linear_id_type get_group_linear_id() const;

    linear_id_type get_local_linear_id() const;

    linear_id_type get_group_linear_range() const;

    linear_id_type get_local_linear_range() const;

    bool leader() const;
};
}
----

[source,c++]
----
id_type get_group_id() const;
----
_Returns_: An `id` representing the index of the ballot-group.

NOTE: This will always be either 0 (representing the group of work-items where
the predicate was true) or 1 (representing the group of work-items where the
predicate was false).

[source,c++]
----
id_type get_local_id() const;
----
_Returns_: An `id` representing the calling work-item's position within
the ballot-group.

[source,c++]
----
range_type get_group_range() const;
----
_Returns_: A `range` representing the number of ballot-groups.

NOTE: This will always return a `range` of 2, as there will always be two groups;
one representing the group of work-items where the predicate was true and
another representing the group of work-items where the predicate was false.

[source,c++]
----
range_type get_local_range() const;
----
_Returns_: A `range` representing the number of work-items in the ballot-group.

[source,c++]
----
id_type get_group_linear_id() const;
----
_Returns_: A linearized version of the `id` returned by `get_group_id()`.

[source,c++]
----
id_type get_local_linear_id() const;
----
_Returns_: A linearized version of the `id` returned by `get_local_linear_id()`.

[source,c++]
----
range_type get_group_linear_range() const;
----
_Returns_: A linearized version of the `id` returned by `get_group_range()`.

[source,c++]
----
range_type get_local_linear_range() const;
----
_Returns_: A linearized version of the `id` returned by `get_local_range()`.

[source,c++]
----
bool leader() const;
----
_Returns_: `true` for exactly one work-item in the ballot-group, if the calling
work-item is the leader of the ballot-group, and `false` for all other
work-items in the ballot-group. The leader of the ballot-group is guaranteed to
be the work-item for which `get_local_id()` returns 0.

=== Class `cluster_group`

Some hardware supports partitioning sub-groups into smaller groups.
This could be achieved with a `ballot_group`, but when the group size is known
at compile-time, the size can be used for optimizations such as loop unrolling.

To allow for predictable behaviour and optimizations, cluster-groups
will have a number of properties:

* The work items in a cluster will be contiguous in the sub_group.
* Clusters sizes must be powers of two, and less than or equal to
`get_max_local_range`.
* For a given cluster size, a work-item will only be in a single cluster and
always the same cluster.
* If `get_local_linear_range` is not evenly divisible by cluster size then the
behaviour is undefined.

These properties also mean that no synchronization is needed to created a
cluster-group, a work-item can independently calculate the cluster it belongs
to, meaning that cluster-groups can be created in divergent control-flow and
without any synchronization.

The `cluster_group` class represents a contiguous set of work-items in a sub-group.

[source, c++]
----
namespace sycl::ext::oneapi {
template <std::size_t ClusterSize>
class cluster_group {
public:
    using id_type = id<1>;
    using range_type = range<1>;
    using linear_id_type = uint32_t;
    static constexpr int dimensions = 1;
    static constexpr sycl::memory_scope fence_scope =
        sycl::memory_scope::sub_group;
    
    id_type get_group_id() const;

    id_type get_local_id() const;

    range_type get_group_range() const;

    range_type get_local_range() const;

    linear_id_type get_group_linear_id() const;

    linear_id_type get_local_linear_id() const;

    linear_id_type get_group_linear_range() const;

    linear_id_type get_local_linear_range() const;

    bool leader() const;
};
}
----

[source,c++]
----
id_type get_group_id() const;
----
_Returns_: An `id` representing the index of the cluster-group.

[source,c++]
----
id_type get_local_id() const;
----
_Returns_: An `id` representing the calling work-item's position within
the cluster-group.

[source,c++]
----
range_type get_group_range() const;
----
_Returns_: A `range` representing the number of cluster-groups.

[source,c++]
----
range_type get_local_range() const;
----
_Returns_: A `range` representing the number of work-items in the cluster-group.

[source,c++]
----
id_type get_group_linear_id() const;
----
_Returns_: A linearized version of the `id` returned by `get_group_id()`.

[source,c++]
----
id_type get_local_linear_id() const;
----
_Returns_: A linearized version of the `id` returned by `get_local_linear_id()`.

[source,c++]
----
range_type get_group_linear_range() const;
----
_Returns_: A linearized version of the `id` returned by `get_group_range()`.

[source,c++]
----
range_type get_local_linear_range() const;
----
_Returns_: A linearized version of the `id` returned by `get_local_range()`.

[source,c++]
----
bool leader() const;
----
_Returns_: `true` for exactly one work-item in the cluster-group, if the calling
work-item is the leader of the cluster-group, and `false` for all other
work-items in the cluster-group. The leader of the cluster-group is guaranteed
to be the work-item for which `get_local_id()` returns 0.

=== Class `tangle_group`

Divergent control flow can lead to a tangle, where only a subset of work-items in a
sub-group are executing the same control flow. In some cases it can be useful
to capture this subset of work-items.

The `tangle_group` class represents a tangle-group, the work-items of sub-group
which form a tangle.

[source, c++]
----
namespace sycl::ext::oneapi {
class tangle_group {
public:
    using id_type = id<1>;
    using range_type = range<1>;
    using linear_id_type = uint32_t;
    static constexpr int dimensions = 1;
    static constexpr sycl::memory_scope fence_scope =
        sycl::memory_scope::sub_group;
    
    id_type get_group_id() const;

    id_type get_local_id() const;

    range_type get_group_range() const;

    range_type get_local_range() const;

    linear_id_type get_group_linear_id() const;

    linear_id_type get_local_linear_id() const;

    linear_id_type get_group_linear_range() const;

    linear_id_type get_local_linear_range() const;

    bool leader() const;
};
}
----

[source,c++]
----
id_type get_group_id() const;
----
_Returns_: An `id` representing the index of the tangle-group.

NOTE: This will always be an `id` with all values set to 0, since there can
only be one tangle-group.

[source,c++]
----
id_type get_local_id() const;
----
_Returns_: An `id` representing the calling work-item's position within
the tangle-group.

[source,c++]
----
range_type get_group_range() const;
----
_Returns_: A `range` representing the number of tangle-groups.

NOTE: This will always return a `range` of 1 as there can only be one
tangle-group.

[source,c++]
----
range_type get_local_range() const;
----
_Returns_: A `range` representing the number of work-items in the tangle-group.

[source,c++]
----
id_type get_group_linear_id() const;
----
_Returns_: A linearized version of the `id` returned by `get_group_id()`.

[source,c++]
----
id_type get_local_linear_id() const;
----
_Returns_: A linearized version of the `id` returned by `get_local_linear_id()`.

[source,c++]
----
range_type get_group_linear_range() const;
----
_Returns_: A linearized version of the `id` returned by `get_group_range()`.

[source,c++]
----
range_type get_local_linear_range() const;
----
_Returns_: A linearized version of the `id` returned by `get_local_range()`.

[source,c++]
----
bool leader() const;
----
_Returns_: `true` for exactly one work-item in the tangle-group, if the calling
work-item is the leader of the tangle-group, and `false` for all other
work-items in the tangle-group. The leader of the tangle-group is guaranteed to
be the work-item for which `get_local_id()` returns 0.

=== Class `opportunistic_group`

Divergent control flow and independent forward progress can lead to work-items
in a sub-group executing in a tangle but not in a concurrent tangle. In some
cases it may be helpful to capture this group and use it for some opportunistic
optimization, the creation of an `opportunistic_group` from a sub-group will
capture this group. One example could be to aggregate an atomic operation across
the work-items in a sub-group ready to perform the atomic, thus reducing the
contention on the atomic. The creation of an `opportunistic_group` does not
require any synchronization because the work-items are implicitly executing in
a concurrent tangle.

The `opportunistic_group` class represents a opportunistic-group, the work-items
of a sub-group which form a concurrent tangle.

[source, c++]
----
namespace sycl::ext::oneapi {
class opportunistic_group {
public:
    using id_type = id<1>;
    using range_type = range<1>;
    using linear_id_type = uint32_t;
    static constexpr int dimensions = 1;
    static constexpr sycl::memory_scope fence_scope =
        sycl::memory_scope::sub_group;
    
    id_type get_group_id() const;

    id_type get_local_id() const;

    range_type get_group_range() const;

    range_type get_local_range() const;

    linear_id_type get_group_linear_id() const;

    linear_id_type get_local_linear_id() const;

    linear_id_type get_group_linear_range() const;

    linear_id_type get_local_linear_range() const;

    bool leader() const;
};
}
----

[source,c++]
----
id_type get_group_id() const;
----
_Returns_: An `id` representing the index of the opportunistic-group.

NOTE: This will always be an `id` with all values set to 0, since there can
only be one opportunistic-group.

[source,c++]
----
id_type get_local_id() const;
----
_Returns_: An `id` representing the calling work-item's position within
the opportunistic-group.

[source,c++]
----
range_type get_group_range() const;
----
_Returns_: A `range` representing the number of opportunistic-groups.

NOTE: This will always return a `range` of 1 as there will only be one
opportunistic-group.

[source,c++]
----
range_type get_local_range() const;
----
_Returns_: A `range` representing the number of work-items in the
opportunistic-group.

[source,c++]
----
id_type get_group_linear_id() const;
----
_Returns_: A linearized version of the `id` returned by `get_group_id()`.

[source,c++]
----
id_type get_local_linear_id() const;
----
_Returns_: A linearized version of the `id` returned by `get_local_linear_id()`.

[source,c++]
----
range_type get_group_linear_range() const;
----
_Returns_: A linearized version of the `id` returned by `get_group_range()`.

[source,c++]
----
range_type get_local_linear_range() const;
----
_Returns_: A linearized version of the `id` returned by `get_local_range()`.

[source,c++]
----
bool leader() const;
----
_Returns_: `true` for exactly one work-item in the opportunistic-group, if the
calling work-item is the leader of the opportunistic-group, and `false` for all
other work-items in the opportunistic-group. The leader of the opportunistic
group is guaranteed to be the work-item for which `get_local_id()` returns 0.

=== Sub-group traits

Additional traits are introduced for detecting whether a group type is a fixed
topology group type or a user-constructed group type.

[source, c++]
----
namespace sycl {
  template <class T>
  struct is_fixed_topology_group;
  template <class T>
  struct is_user_constructed_group;

  template <class T>
  inline constexpr bool is_fixed_topology_group_v
   = is_fixed_topology_group<T>::value;
  template <class T>
  inline constexpr bool is_user_constructed_group_v
    = is_user_constructed_group<T>::value;
}
----

`is_fixed_group` is `std::true_type` if `T` is either `group` or `sub_group` and
`is_user_constructed_group` is `std::true_type` if `T` is either `ballot_group`,
`cluster_group`, `tangle_group` or `opportunisic_group`.

The `is_group` is `std::true_type` if `T` is either `ballot_group`,
`cluster_group`, `tangle_group` or `opportunisic_group`.

=== Free functions

Several free functions are introduced for creating the new group types from a
sub-group.

[source, c++]
----
namespace ext::oneapi {

template <typename Group>
ballot_group get_ballot_group(Group group, bool predicate) const; // (1)

// This can be called in divergent control flow since no synchronization is 
// needed.
template <typename Group, size_t ClusterSize> 
cluster_group<ClusterSize> get_cluster_group(Group group) const; // (2)

template <typename Group>
tangle_group get_tangle_group(Group group) const; // (3)

template <typename Group>
opportunistic_group get_opportunistic_group(Group group) const; // (4)

} // namespace ext::oneapi

----

1. Constraints: Available only if `sycl::is_group_v<std::decay_t<Group>> &&
   std::is_same_v<Group, sycl::sub_group>` is true.
   Returns: A `ballot_group` consisting of the work-items in
   `group` for which `predicate` is true if the precidate is true for the
   executing work-item, otherwise consisting of the work-items in `group` for
   which `predicate` is false.
   This will cause synchronization of the source_group.
2. Constraints: Available only if `sycl::is_group_v<std::decay_t<Group>> &&
   std::is_same_v<Group, sycl::sub_group>` is true.
   Returns: A `cluster_group<ClusterSize>` consisting of the work-items in
   `group` that are in the same cluster as the executing work-item.
   This can be called in divergent control flow since no synchronization is
   needed.
3. Constraints: Available only if `sycl::is_group_v<std::decay_t<Group>> &&
   std::is_same_v<Group, sycl::sub_group>` is true.
   Returns: A `tangle_group` consisting of the work-items in `group` which
   are part of the same tangle. This function must be called in convergent
   control flow as synchronization may be required to establish the full
   tangle-group.
4. Constraints: Available only if `sycl::is_group_v<std::decay_t<Group>> &&
   std::is_same_v<Group, sycl::sub_group>` is true.
   Returns: A `opportunistic_group` consisting of the work-items in
   `group` which are part of the same concurrent tangle. This can be called in
   divergent control flow since no synchronization is required.

NOTE: It is expected that in the future these functions will be expanded to
allow the creation of these group types from other kinds of groups, however, for
now only sub-groups are supported.

An additional free-function is available in the `this_kernel` namespace to
provide direct access to an `opportunistic_group` created implicitly from
a `sub_group`.

[source, c++]
----
namespace ext::oneapi::this_kernel {

opportunistic_group get_opportunistic_group(); // (5)

} // namespace ext::oneapi::this_kernel
----

5. _Returns_: An `opportunistic_group` consisting of all work-items in the
   same sub-group as the calling work-item which are also part of the same
   concurrent tangle.

=== Group Functions

The following group functions support `ballot_group`, `cluster_group`,
`tangle_group` and `opportunistic_group` group types:

* `group_barrier`
* `broadcast`

=== Group Algorithms

The following group algorithms support `ballot_group`, `cluster_group`,
`tangle_group` and `opportunistic_group` group types:

* `joint_any_of` and `any_of_group`
* `joint_all_of` and `all_of_group`
* `joint_none_of` and `none_of_group`
* `shift_group_left`
* `shift_group_right`
* `permute_group_by_xor`
* `select_from_group`
* `joint_reduce`
* `reduce_over_group`
* `joint_exclusive_scan` and `exclusive_scan_over_group`
* `joint_inclusive_scan` and `inclusive_scan_over_group`

This proposal would also build on the
link:https://github.com/intel/llvm/pull/4950[prospective proposal] to generalize
`sycl::group::async_work_group_copy` and `sycl::group::wait_for` to work with
sub-groups.

Both `sycl::ext::oneapi::experimental::async_group_copy` and
`sycl::ext::oneapi::experimental::wait_for` would work with
`opportunistic_group`, `ballot_group`, and `cluster_group` with the same
semantics.

== Examples

=== Example of `opportunistic_group`

The following example shows an atomic pointer being incremented.
It is expected that all the work-items in the sub_group will increment the
atomic value, but we opportunistically capture the groups of work-items as they
arrive to this point in the control flow.

[source, c++]
----
template <sycl::memory_order order, sycl::memory_scope scope, sycl::access::address_space addr_space>
int atomic_aggregate_inc(sycl::sub_group sub_group, sycl::atomic_ref<int, order, scope, addr_space> ptr) {
    sycl::ext::oneapi::opportunistic_group active_group = sycl::ext::oneapi::get_opportunistic_group(sub_group);
    int count = active_group.get_local_linear_range();
    int old_value;
    if (active_group.leader()) {
        old_value = ptr.fetch_add(count);
    }
    // return the value the individual work-item might have received if it had worked alone.
    auto index_in_group = active_group.get_local_linear_id();
    return sycl::select_from_group(active_group, old_value, 0) + index_in_group; 
}
----

=== Example of `ballot_group`

In the following example a sub-group is split up and one branch of the control
flow performs a group barrier with a subset of the sub-group. This subset is
then further subdivided.

[source, c++]
----
auto sub_group = it.get_sub_group();
auto will_branch = sub_group.get_local_linear_id() % 2 == 0;
// get group representing the subset of the sub-group that took the branch
sycl::ext::oneapi::ballot_group inner = sycl::ext::oneapi::get_ballot_group(sub_group, will_branch);
if (will_branch)
{
  // synchronize across the work-items that took the branch
  sycl::group_barrier(inner);

  // reduce across subset of outer work-items that took the branch
  float ix = sycl::reduce_over_group(inner, x, plus<>());

  // once again diverge the groups
  auto will_branch_further = inner.get_local_linear_id() < 8;
  auto inner_inner = get_ballot_group(inner, will_branch_further);
  if (will_branch_further) {
      // still synchronizing without deadlock
      sycl::group_barrier(inner_inner);
  }
}

// take a subset of an opportunistic group
auto matching_active_items = get_ballot_group(get_opportunistic_group(sub_group), some_predicate());
----

This will allow functions to cause divergent control flow without having to
consider how to converge again to synchronize.

=== Example of `cluster_group`

[source, c++]
----
// sum the buffer in groups of 8
constexpr std::size_t cluster_size = 8;
auto sub_group = it.get_sub_group();
auto cluster = get_cluster_group<cluster_size>(sub_group);
// compiler knows that exactly 3 shuffles are needed to sum the values
auto result = sycl::reduce_over_group(cluster, buf[it.get_local_linear_id()], sycl::plus<>());
if (cluster.leader()){
    buf[it.get_local_linear_id()/cluster_size] = result;
}
----

Another use of `cluster_group` would be to provide an interface with a compile-time known size of cluster-group as an argument.

[source, c++]
----
void func_that_needs_4_work_items(sycl::ext::oneapi::cluster_group<4> group);
----


== Issues

* The wording of the group functions and group algorithms is still to be fleshed
out fully.
* Wording needs to be introduced to describe when particular non-uniform
sub-groups can be created from other non-uniform sub-groups.
* What happens when work-items in different control-flow call
ext_oneapi_get_opportunistic_group?
* The conditions for calling the group functions and algorithms need to be
decided on. It makes sense that reaching a group algorithm from a different
control-flow should be undefined behaviour, but is that at all enforcable or
detectable? Should it be possible to call group algorithms and group functions
with different group at the same time? Multiple ballot-groups with
non-overlapping members trying to do a reduce at the same time seems like a
common use case, but will hardware support it?
* If the main purpose of `group_ballot` from the
link:https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/SubGroupMask/SubGroupMask.asciidoc[sub group mask proposal]
is to represent subsets of sub-groups, then this work would make that redundant.
* To create a ballot-group, members of a sub-groups, ballot-groups,
opportunistic-groups, and cluster-groups could all broadcast the result of some
predicate function.
* The creation of a cluster-group only depends on the size of a sub-group and
the location of a work-item within that sub-group, meaning any work-item can
calculate the cluster-group it belongs in with no synchronization. It is
indirect to use another group in the creation of a cluster-group when the
implementation will be querying the containing sub-group and ignoring other
information.
* To create an opportunistic-group from another group, would likely involve
finding the intersection of a new opportunistic-group and another group. Without
hardware support, this would require synchronization between work-items and is
effectively equal to creating a ballot-group, so a ballot-group should be used
instead.
