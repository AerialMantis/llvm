= sycl_ext_oneapi_non_uniform_sub_groups

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en

:blank: pass:[ +]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}


== Notice

[%hardbreaks]
Copyright (C) 2022-2023 Intel Corporation.  All rights reserved.

Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are trademarks
of The Khronos Group Inc.  OpenCL(TM) is a trademark of Apple Inc. used by
permission by Khronos.


== Contact

To report problems with this extension, please open a new issue at:

https://github.com/intel/llvm/issues


== Dependencies

This extension is written against the SYCL 2020 revision 6 specification.  All
references below to the "core SYCL specification" or to section numbers in the
SYCL specification refer to that revision.

This extension also depends on the following other SYCL extensions:

* link:https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/supported/sycl_ext_oneapi_sub_group_mask.asciidoc[sycl_ext_oneapi_sub_group_mask]
* link:https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/proposed/sycl_ext_oneapi_root_group.asciidoc[sycl_ext_oneapi_root_group]


== Status

This is a proposed extension specification, intended to gather community
feedback.  Interfaces defined in this specification may not be implemented yet
or may be in a preliminary state.  The specification itself may also change in
incompatible ways before it is finalized.  *Shipping software products should
not rely on APIs defined in this specification.*


== Overview

To fully exploit the available resources, modern hardware architectures allow
for further sub-divisions of sub-groups. Managing synchronization in divergent
control-flow can become awkward, especially when programming library code.
This proposal introduces new classes to represent sub-divisions of SYCL
sub-groups, allowing for easier synchronization and cooperation. These new
classes can be used as function arguments to convey exactly what group the
function is expecting, simplifying the interface and greatly reducing the amount
of delicate wording needed in function documentation. The group functions and
algorithms will also be updated to simplify use of these groups.

This extension introduces additions to the SYCL execution model which allows for
non-uniform sub-group types which can be created from sub-groups in order to
support various use cases of divergent control flow and forward progress
guarantees.

The extension introduces new classes for these group types, traits for detecting
them and free functions for creating them.

NOTE: It is expected that in the future these functions will be expanded to
allow the creation of these group types from other kinds of groups, however, for
now only sub-groups are supported.


== Specification

=== Control Flow

The SYCL specification defines
link:https://registry.khronos.org/SYCL/specs/sycl-2020/html/sycl-2020.html#control-flow[control
flow] as below:

> When all work-items in a group are executing the same sequence of statements,
> they are said to be executing under _converged_ control flow. Control flow
> _diverges_ when different work-items in a group execute a different sequence of
> statements, typically as a result of evaluating conditions differently (e.g.
> in selection statements or loops).

This extension introduces some new terminology to describe other kinds of
control flow, to simplify the description of the behavior for new group types.

A work-item is said to have _active_ control flow for a given point of
execution if it follows the sequence of statements currently being executed.

Two or more work-items are considered to have _concurrent_ execution at a given
point if they execute together. The amount of and granularity of concurrent
execution is implementation-defined.

A _tangle_ is a collection of work-items from the same sub-group executing
under converged control flow.

A _concurrent tangle_ is a subset of a tangle representing a set of
work-items executing under converged control flow and with concurrent
execution.


=== Group Taxonomy

_Fixed topology groups_ are groups which represent the hierarchical execution
model topology used by SYCL kernels. These groups are implicitly created by an
implementation when a SYCL kernel function is enqueued. The following group
types are fixed topology groups:

- `root_group` (if sycl_ext_oneapi_root_group is supported)
- `group`
- `sub_group`

_User-constructed groups_ are explicitly created by a developer (e.g. by
partitioning one of the fixed topology groups). This extension introduces the
following user-constructed groups:

- `ballot_group`
- `cluster_group`
- `tangle_group`
- `opportunistic_group`

The `is_fixed_topology_group` and `is_user_constructed_group` traits can be
used to detect whether a group type represents a fixed topology or
user-constructed group, respectively.

[source, c++]
----
namespace sycl::ext::oneapi {

  template <class T>
  struct is_fixed_topology_group;

  template <class T>
  inline constexpr
  bool is_fixed_topology_group_v = is_fixed_topology_group<T>::value;


  template <class T>
  struct is_user_constructed_group;

  template <class T>
  inline constexpr bool
  is_user_constructed_group_v = is_user_constructed_group<T>::value;

} // namespace sycl::ext::oneapi
----

`is_fixed_topology_group<T>::value` is `std::true_type` if `T` is one of:
`root_group`, `group` or `sub_group`.

`is_user_constructed_group<T>::value` is `std::true_type` if `T` is one of:
`ballot_group`, `cluster_group`, `tangle_group` or `opportunisic_group`.


=== Ballot-Groups

A ballot-group is a non-contiguous subset of a group, representing a collection
of all work-items in the group that share the same value of some predicate.
Ballot-groups are always created in a range of two: the first ballot-group
contains all work-items where the predicate is true, and the second
ballot-group contains all work-items where the predicate is false.


==== Creation

New ballot-groups are created by partitioning an existing group, using the
`get_ballot_group` free-function.

NOTE: Creating a ballot-group requires synchronization of the parent group,
since work-items must exchange predicate values in order to determine group
membership.

[source, c++]
----
namespace ext::oneapi {

template <typename Group>
ballot_group get_ballot_group(Group group, bool predicate);

} // namespace ext::oneapi
----
_Constraints_: Available only if `sycl::is_group_v<std::decay_t<Group>> &&
std::is_same_v<Group, sycl::sub_group>` is true.

_Preconditions_: All work-items in `group` must encounter this function in
converged control flow.

_Effects_: Synchronizes all work-items in `group`.

_Returns_: A `ballot_group` consisting of the work-items in `group` for which
`predicate` has the same value as the calling work-item.


==== `ballot_group` Class

[source, c++]
----
namespace sycl::ext::oneapi {

class ballot_group {
public:
    using id_type = id<1>;
    using range_type = range<1>;
    using linear_id_type = uint32_t;
    static constexpr int dimensions = 1;
    static constexpr sycl::memory_scope fence_scope =
        sycl::memory_scope::sub_group;
    
    id_type get_group_id() const;

    id_type get_local_id() const;

    range_type get_group_range() const;

    range_type get_local_range() const;

    linear_id_type get_group_linear_id() const;

    linear_id_type get_local_linear_id() const;

    linear_id_type get_group_linear_range() const;

    linear_id_type get_local_linear_range() const;

    bool leader() const;
};

}
----

[source,c++]
----
id_type get_group_id() const;
----
_Returns_: An `id` representing the index of the ballot-group.

NOTE: This will always be either 0 (representing the group of work-items where
the predicate was true) or 1 (representing the group of work-items where the
predicate was false).

[source,c++]
----
id_type get_local_id() const;
----
_Returns_: An `id` representing the calling work-item's position within
the ballot-group.

[source,c++]
----
range_type get_group_range() const;
----
_Returns_: A `range` representing the number of ballot-groups.

NOTE: This will always return a `range` of 2, as there will always be two groups;
one representing the group of work-items where the predicate was true and
another representing the group of work-items where the predicate was false.

[source,c++]
----
range_type get_local_range() const;
----
_Returns_: A `range` representing the number of work-items in the ballot-group.

[source,c++]
----
id_type get_group_linear_id() const;
----
_Returns_: A linearized version of the `id` returned by `get_group_id()`.

[source,c++]
----
id_type get_local_linear_id() const;
----
_Returns_: A linearized version of the `id` returned by `get_local_linear_id()`.

[source,c++]
----
range_type get_group_linear_range() const;
----
_Returns_: A linearized version of the `id` returned by `get_group_range()`.

[source,c++]
----
range_type get_local_linear_range() const;
----
_Returns_: A linearized version of the `id` returned by `get_local_range()`.

[source,c++]
----
bool leader() const;
----
_Returns_: `true` for exactly one work-item in the ballot-group, if the calling
work-item is the leader of the ballot-group, and `false` for all other
work-items in the ballot-group. The leader of the ballot-group is guaranteed to
be the work-item for which `get_local_id()` returns 0.


==== Usage Example

In the following example a sub-group is split up and one branch of the control
flow performs a group barrier with a subset of the sub-group. This subset is
then further subdivided.

[source, c++]
----
auto sub_group = it.get_sub_group();
auto will_branch = sub_group.get_local_linear_id() % 2 == 0;
// get group representing the subset of the sub-group that took the branch
sycl::ext::oneapi::ballot_group inner = sycl::ext::oneapi::get_ballot_group(sub_group, will_branch);
if (will_branch)
{
  // synchronize across the work-items that took the branch
  sycl::group_barrier(inner);

  // reduce across subset of outer work-items that took the branch
  float ix = sycl::reduce_over_group(inner, x, plus<>());

  // once again diverge the groups
  auto will_branch_further = inner.get_local_linear_id() < 8;
  auto inner_inner = get_ballot_group(inner, will_branch_further);
  if (will_branch_further) {
      // still synchronizing without deadlock
      sycl::group_barrier(inner_inner);
  }
}

// take a subset of an opportunistic group
auto matching_active_items = get_ballot_group(get_opportunistic_group(sub_group), some_predicate());
----

This will allow functions to cause divergent control flow without having to
consider how to converge again to synchronize.


=== Cluster-Groups

A cluster-group is a contiguous collection of work-items created by subdividing
a group into equally sized parts, such that each work-item is a member of
exactly one cluster. The size of a cluster-group is a static (compile-time)
property.


==== Creation

New cluster-groups are created by partitioning an existing group, using the
`get_cluster_group` free-function.

NOTE: Creating a cluster-group does not require synchronization of the parent
group, since work-items can independently identify cluster members given a
fixed cluster size.

[source, c++]
----
namespace ext::oneapi {

template <size_t ClusterSize, typename Group> 
cluster_group<ClusterSize> get_cluster_group(Group group);

} // namespace ext::oneapi
----

_Constraints_: Available only if `sycl::is_group_v<std::decay_t<Group>> &&
std::is_same_v<Group, sycl::sub_group>` is true. `ClusterSize` must be positive
and a power of 2.

_Preconditions_: `ClusterSize` must be less than or equal to the result of
`group.get_max_local_range()`. `group.get_local_linear_range()` must be evenly
divisible by `ClusterSize`.

_Returns_: A `cluster_group<ClusterSize>` consisting of all work-items in
`group` that are in the same cluster as the calling work-item.


==== `cluster_group` Class

[source, c++]
----
namespace sycl::ext::oneapi {

template <std::size_t ClusterSize>
class cluster_group {
public:
    using id_type = id<1>;
    using range_type = range<1>;
    using linear_id_type = uint32_t;
    static constexpr int dimensions = 1;
    static constexpr sycl::memory_scope fence_scope =
        sycl::memory_scope::sub_group;
    
    id_type get_group_id() const;

    id_type get_local_id() const;

    range_type get_group_range() const;

    range_type get_local_range() const;

    linear_id_type get_group_linear_id() const;

    linear_id_type get_local_linear_id() const;

    linear_id_type get_group_linear_range() const;

    linear_id_type get_local_linear_range() const;

    bool leader() const;
};

}
----

[source,c++]
----
id_type get_group_id() const;
----
_Returns_: An `id` representing the index of the cluster-group.

[source,c++]
----
id_type get_local_id() const;
----
_Returns_: An `id` representing the calling work-item's position within
the cluster-group.

[source,c++]
----
range_type get_group_range() const;
----
_Returns_: A `range` representing the number of cluster-groups.

[source,c++]
----
range_type get_local_range() const;
----
_Returns_: A `range` representing the number of work-items in the cluster-group.

[source,c++]
----
id_type get_group_linear_id() const;
----
_Returns_: A linearized version of the `id` returned by `get_group_id()`.

[source,c++]
----
id_type get_local_linear_id() const;
----
_Returns_: A linearized version of the `id` returned by `get_local_linear_id()`.

[source,c++]
----
range_type get_group_linear_range() const;
----
_Returns_: A linearized version of the `id` returned by `get_group_range()`.

[source,c++]
----
range_type get_local_linear_range() const;
----
_Returns_: A linearized version of the `id` returned by `get_local_range()`.

[source,c++]
----
bool leader() const;
----
_Returns_: `true` for exactly one work-item in the cluster-group, if the calling
work-item is the leader of the cluster-group, and `false` for all other
work-items in the cluster-group. The leader of the cluster-group is guaranteed
to be the work-item for which `get_local_id()` returns 0.


==== Usage Examples

[source, c++]
----
// sum the buffer in groups of 8
constexpr std::size_t cluster_size = 8;
auto sub_group = it.get_sub_group();
auto cluster = get_cluster_group<cluster_size>(sub_group);
// compiler knows that exactly 3 shuffles are needed to sum the values
auto result = sycl::reduce_over_group(cluster, buf[it.get_local_linear_id()], sycl::plus<>());
if (cluster.leader()){
    buf[it.get_local_linear_id()/cluster_size] = result;
}
----

Another use of `cluster_group` would be to provide an interface with a
compile-time known size of cluster-group as an argument.

[source, c++]
----
void func_that_needs_4_work_items(sycl::ext::oneapi::cluster_group<4> group);
----


=== Tangle-Groups

A tangle-group is a non-contiguous subset of a group representing work-items
executing in a tangle. A tangle-group can therefore be used to capture all
work-items currently executing the same control flow.


==== Creation

New tangle-groups are created by partitioning an existing group, using the
`get_tangle_group` free-function.

NOTE: Creating a tangle-group may require synchronization of the parent group
on some devices, since it may be necessary to wait for work-items to
reconverge. For consistency, synchronization is required by all
implementations.

[source, c++]
----
namespace ext::oneapi {

template <typename Group>
tangle_group get_tangle_group(Group group);

} // namespace ext::oneapi
----

_Constraints_: Available only if `sycl::is_group_v<std::decay_t<Group>> &&
std::is_same_v<Group, sycl::sub_group>` is true.

_Preconditions_: All work-items in `group` must encounter this function in
converged control flow.

_Effects_: Synchronizes all work-items in `group`.

_Returns_: A `tangle_group` consisting of the work-items in `group` which are
part of the same tangle.


==== `tangle_group` Class

[source, c++]
----
namespace sycl::ext::oneapi {

class tangle_group {
public:
    using id_type = id<1>;
    using range_type = range<1>;
    using linear_id_type = uint32_t;
    static constexpr int dimensions = 1;
    static constexpr sycl::memory_scope fence_scope =
        sycl::memory_scope::sub_group;
    
    id_type get_group_id() const;

    id_type get_local_id() const;

    range_type get_group_range() const;

    range_type get_local_range() const;

    linear_id_type get_group_linear_id() const;

    linear_id_type get_local_linear_id() const;

    linear_id_type get_group_linear_range() const;

    linear_id_type get_local_linear_range() const;

    bool leader() const;
};

}
----

[source,c++]
----
id_type get_group_id() const;
----
_Returns_: An `id` representing the index of the tangle-group.

NOTE: This will always be an `id` with all values set to 0, since there can
only be one tangle-group.

[source,c++]
----
id_type get_local_id() const;
----
_Returns_: An `id` representing the calling work-item's position within
the tangle-group.

[source,c++]
----
range_type get_group_range() const;
----
_Returns_: A `range` representing the number of tangle-groups.

NOTE: This will always return a `range` of 1 as there can only be one
tangle-group.

[source,c++]
----
range_type get_local_range() const;
----
_Returns_: A `range` representing the number of work-items in the tangle-group.

[source,c++]
----
id_type get_group_linear_id() const;
----
_Returns_: A linearized version of the `id` returned by `get_group_id()`.

[source,c++]
----
id_type get_local_linear_id() const;
----
_Returns_: A linearized version of the `id` returned by `get_local_linear_id()`.

[source,c++]
----
range_type get_group_linear_range() const;
----
_Returns_: A linearized version of the `id` returned by `get_group_range()`.

[source,c++]
----
range_type get_local_linear_range() const;
----
_Returns_: A linearized version of the `id` returned by `get_local_range()`.

[source,c++]
----
bool leader() const;
----
_Returns_: `true` for exactly one work-item in the tangle-group, if the calling
work-item is the leader of the tangle-group, and `false` for all other
work-items in the tangle-group. The leader of the tangle-group is guaranteed to
be the work-item for which `get_local_id()` returns 0.


==== Usage Examples

TODO: Usage example for tangle groups.


=== Opportunistic-Groups

An opportunistic-group is a non-contiguous subset of a sub-group, representing
the work-items of a concurrent tangle.

In SYCL implementations where work-items have strong forward progress
guarantees (and can therefore make progress independently of other work-items
in the same sub-group), divergent control flow can lead to work-items in a
sub-group executing in a tangle but not in a concurrent tangle.

In some cases it may be helpful to capture this group and use it for
opportunistic optimizations.


==== Creation

Opportunistic groups are created by calls to the `get_opportunistic_group()`
free-function. Each call to `get_opportunistic_group()` returns a different
group. There are no guarantees that a group returned by
`get_opportunistic_group()` will contain all work-items executing the same
control flow, nor the the same set of work-items as the group returned by any
previous call to `get_opportunistic_group()`.

NOTE: Creating an opportunistic group does not require synchronization because
it is designed to capture whichever set of work-items happen to call
`get_opportunistic_group()` simultaneously.

[source, c++]
----
namespace ext::oneapi::this_kernel {

opportunistic_group get_opportunistic_group();

} // namespace ext::oneapi::this_kernel
----

_Returns_: An `opportunistic_group` consisting of all work-items in the same
sub-group as the calling work-item which are also part of the same concurrent
tangle.


==== `opportunistic_group` Class

[source, c++]
----
namespace sycl::ext::oneapi {

class opportunistic_group {
public:
    using id_type = id<1>;
    using range_type = range<1>;
    using linear_id_type = uint32_t;
    static constexpr int dimensions = 1;
    static constexpr sycl::memory_scope fence_scope =
        sycl::memory_scope::sub_group;
    
    id_type get_group_id() const;

    id_type get_local_id() const;

    range_type get_group_range() const;

    range_type get_local_range() const;

    linear_id_type get_group_linear_id() const;

    linear_id_type get_local_linear_id() const;

    linear_id_type get_group_linear_range() const;

    linear_id_type get_local_linear_range() const;

    bool leader() const;
};

}
----

[source,c++]
----
id_type get_group_id() const;
----
_Returns_: An `id` representing the index of the opportunistic-group.

NOTE: This will always be an `id` with all values set to 0, since there can
only be one opportunistic-group.

[source,c++]
----
id_type get_local_id() const;
----
_Returns_: An `id` representing the calling work-item's position within
the opportunistic-group.

[source,c++]
----
range_type get_group_range() const;
----
_Returns_: A `range` representing the number of opportunistic-groups.

NOTE: This will always return a `range` of 1 as there will only be one
opportunistic-group.

[source,c++]
----
range_type get_local_range() const;
----
_Returns_: A `range` representing the number of work-items in the
opportunistic-group.

[source,c++]
----
id_type get_group_linear_id() const;
----
_Returns_: A linearized version of the `id` returned by `get_group_id()`.

[source,c++]
----
id_type get_local_linear_id() const;
----
_Returns_: A linearized version of the `id` returned by `get_local_linear_id()`.

[source,c++]
----
range_type get_group_linear_range() const;
----
_Returns_: A linearized version of the `id` returned by `get_group_range()`.

[source,c++]
----
range_type get_local_linear_range() const;
----
_Returns_: A linearized version of the `id` returned by `get_local_range()`.

[source,c++]
----
bool leader() const;
----
_Returns_: `true` for exactly one work-item in the opportunistic-group, if the
calling work-item is the leader of the opportunistic-group, and `false` for all
other work-items in the opportunistic-group. The leader of the opportunistic
group is guaranteed to be the work-item for which `get_local_id()` returns 0.


==== Usage Example

The following example shows an atomic pointer being incremented.
It is expected that all the work-items in the sub_group will increment the
atomic value, but we opportunistically capture the groups of work-items as they
arrive to this point in the control flow.

[source, c++]
----
template <sycl::memory_order order, sycl::memory_scope scope, sycl::access::address_space addr_space>
int atomic_aggregate_inc(sycl::sub_group sub_group, sycl::atomic_ref<int, order, scope, addr_space> ptr) {
    sycl::ext::oneapi::opportunistic_group active_group = sycl::ext::oneapi::get_opportunistic_group(sub_group);
    int count = active_group.get_local_linear_range();
    int old_value;
    if (active_group.leader()) {
        old_value = ptr.fetch_add(count);
    }
    // return the value the individual work-item might have received if it had worked alone.
    auto index_in_group = active_group.get_local_linear_id();
    return sycl::select_from_group(active_group, old_value, 0) + index_in_group;
}
----

=== Group Functions

The following group functions support `ballot_group`, `cluster_group`,
`tangle_group` and `opportunistic_group` group types:

* `group_barrier`
* `broadcast`


=== Group Algorithms

The following group algorithms support `ballot_group`, `cluster_group`,
`tangle_group` and `opportunistic_group` group types:

* `joint_any_of` and `any_of_group`
* `joint_all_of` and `all_of_group`
* `joint_none_of` and `none_of_group`
* `shift_group_left`
* `shift_group_right`
* `permute_group_by_xor`
* `select_from_group`
* `joint_reduce`
* `reduce_over_group`
* `joint_exclusive_scan` and `exclusive_scan_over_group`
* `joint_inclusive_scan` and `inclusive_scan_over_group`


== Issues

* The wording of the group functions and group algorithms is still to be fleshed
out fully.
* Wording needs to be introduced to describe when particular non-uniform
sub-groups can be created from other non-uniform sub-groups.
* What happens when work-items in different control-flow call
ext_oneapi_get_opportunistic_group?
* The conditions for calling the group functions and algorithms need to be
decided on. It makes sense that reaching a group algorithm from a different
control-flow should be undefined behaviour, but is that at all enforcable or
detectable? Should it be possible to call group algorithms and group functions
with different group at the same time? Multiple ballot-groups with
non-overlapping members trying to do a reduce at the same time seems like a
common use case, but will hardware support it?
* If the main purpose of `group_ballot` from the
link:https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/SubGroupMask/SubGroupMask.asciidoc[sub group mask proposal]
is to represent subsets of sub-groups, then this work would make that redundant.
* To create a ballot-group, members of a sub-groups, ballot-groups,
opportunistic-groups, and cluster-groups could all broadcast the result of some
predicate function.
* The creation of a cluster-group only depends on the size of a sub-group and
the location of a work-item within that sub-group, meaning any work-item can
calculate the cluster-group it belongs in with no synchronization. It is
indirect to use another group in the creation of a cluster-group when the
implementation will be querying the containing sub-group and ignoring other
information.
* To create an opportunistic-group from another group, would likely involve
finding the intersection of a new opportunistic-group and another group. Without
hardware support, this would require synchronization between work-items and is
effectively equal to creating a ballot-group, so a ballot-group should be used
instead.
